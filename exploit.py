# clone https://github.com/nils-wisiol/pypuf/tree/v1 and copy this file into the cloned repository before execution

from pwn import *
import numpy as np
from tqdm import tqdm

from pypuf import tools
from pypuf.learner.regression.logistic_regression import LogisticRegression
from pypuf.simulation.arbiter_based.ltfarray import LTFArray
from pypuf.simulation.arbiter_based.arbiter_puf import XORArbiterPUF

num_bits = 64 

def attack_rspuf():
    s = remote('localhost', 10110)
    challenges = []
    responses = []
    # this should give us close to 100% accuracy
    print("[*] OBSERVING 22,000 challenge-response-pairs to train our model on")
    for n in tqdm(range(22000)):
        c = s.recvuntil(b']').split(b'[')[-1]
        challenges.append(eval(b'[' + c))
        s.sendline()
        r = s.recvuntil(b'1').split(b"try ")[-1]
        responses.append(eval(r))

    challenges = np.array(challenges)
    responses = np.array(responses)
    print(challenges.shape)     

    model = train(challenges, responses)

    l = s.recvuntil(b']')
    # flag format is ENO{...}
    while b'ENO' not in l:
        print(l)
        c = b'[' + l.split(b'[')[-1]

        r = str(model.eval(np.array([eval(c)]))[0]).encode()
        s.sendline(r)
        l = s.recvuntil(b']')
    print(l)


def train(challenges, responses):
    # train model from obtained CRPs
    t_pairs = challenges[:-128].shape[0]
    training_set = tools.ChallengeResponseSet(challenges[:-128], responses[:-128])

    # this has to be reversed from the binary. challenge shape, num_bits and that it is a 4-xor arbiter
    lr_learner = LogisticRegression(
        t_set=training_set,
        n=num_bits,
        k=4,
        transformation=LTFArray.transform_atf,
        combiner=LTFArray.combiner_xor,
    )

    print("[*] BEGIN TRAINING")
    model = lr_learner.learn()
    

    resp0 = model.eval(challenges[-128:])
    accuracy = calc_acc(resp0, responses[-128:])

    print('[+] LEARNED a {}-bit 4-xor XOR Arbiter PUF from {} CRPs with accuracy {}'.format(challenges.shape[1], t_pairs, accuracy))
    
    return model


def calc_acc(resp0, resp1):
    num = len(resp0)
    return 1 - (num - np.count_nonzero(resp0 == resp1)) / num


if __name__=='__main__':
    attack_rspuf()
